# Name of the workflow as it appears in the GitHub Actions UI
name: Build and Publish ARM64 Docker Image

on:
  workflow_dispatch:

# Define jobs for the workflow
jobs:
  build-and-push-arm64:
    # Name of the job
    name: Build and Push ARM64 Image

    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Permissions needed for the job
    permissions:
      contents: read # To checkout the repository code
      packages: write # To publish packages to GitHub Container Registry

    steps:
      # Step 0: Cleanup space
      - name: Delete huge unnecessary tools folder
        run: rm -rf /opt/hostedtoolcache

      # Step 1: Checkout the repository code
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          lfs: true

      # Step 2: Set up QEMU for multi-platform builds
      # This enables building images for different architectures (like ARM64)
      # on an x86-64 runner.
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      # Step 3: Set up Docker Buildx
      # Buildx is a Docker CLI plugin that extends the docker build command
      # with powerful capabilities like building for multiple platforms, caching, etc.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 4: Log in to GitHub Container Registry (GHCR)
      # Uses the GITHUB_TOKEN to authenticate with GHCR
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }} # The GitHub username of the person who triggered the workflow
          password: ${{ secrets.GITHUB_TOKEN }} # The GitHub token provided by the workflow context

      # Step 5: Extract metadata (tags, labels) for the Docker image
      # This step helps in generating consistent image tags.
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }} # The base image name for GHCR
          tags: |
            # Assign 'latest' tag if pushed to main branch OR if it's a tag (e.g., v1.0)
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') }}
            type=sha,format=long # Tag with the full Git SHA
            type=ref,event=branch # Tag with the branch name (e.g., 'main')
            type=ref,event=pr # Tag with PR number (e.g., 'pr-123')
            type=semver,pattern={{version}} # Tag with semantic version if a tag (e.g., 'v1.0.0' -> '1.0.0')

      # Step 6: Build and Push the ARM64 Docker Image
      # This is the core step where the image is built and pushed to GHCR.
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: . # The build context (where your Dockerfile is located, usually the root of the repo)
          file: ./Dockerfile # Path to your Dockerfile (default is './Dockerfile')
          platforms: linux/arm64 # Specify the target platform as ARM64
          push: ${{ github.event_name != 'pull_request' }} # Only push on push events, not PRs
          tags: ${{ steps.meta.outputs.tags }} # Use the tags generated by the metadata action
          labels: ${{ steps.meta.outputs.labels }} # Apply labels generated by the metadata action
          cache-from: type=gha # Enable caching using GitHub Actions cache
          cache-to: type=gha,mode=max # Store build cache to GitHub Actions cache